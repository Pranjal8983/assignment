#Can you explain the benefits of using a virtual environment for python applications?
Using a virtual environment for Python applications offers several benefits:
Dependency Isolation:Virtual environments create isolated spaces for each project, preventing conflicts between different projects that might require different versions of the same library.
Reproducibility and Portability:By creating a requirements.txt file within a virtual environment, we can easily document and share the exact dependencies and their versions needed for a project.
Cleaner System-Wide Python Installation:Virtual environments prevent the cluttering of our global Python installation with project-specific packages.
This keeps our system Python clean and stable, avoiding potential issues with system-level scripts or other applications relying on the global installation.
Testing with Different Python Versions:we can create virtual environments with different Python versions, allowing us to test our application's compatibility across various Python releases without affecting our main Python installation.
Enhanced Security: Isolating dependencies within a virtual environment can mitigate risks associated with unintentional library upgrades or security vulnerabilities that might affect a global installation.


Build & push Docker image
docker build -t pranjaldeka/flask-mongo:latest .
docker push pranjaldeka/flask-mongo:latest


5) README â€” step-by-step (Minikube)
Prerequisites

Minikube, kubectl, docker installed locally

Start minikube (example):
minikube start --driver=docker
(Option A) Use Minikube Docker env to build locally:
eval $(minikube -p minikube docker-env)
docker build -t pranjaldeka/flask-mongo:latest .


Apply Secrets and PV/PVC
kubectl apply -f mongo-secret.yaml
kubectl apply -f mongo-pv-pvc.yaml

Deploy MongoDB
kubectl apply -f mongo-service.yaml
kubectl apply -f mongo-statefulset.yaml

Wait for the pod and PVC to be ready:
kubectl get pods -l app=mongo -w
kubectl get pvc

Deploy Flask

kubectl apply -f flask-deployment.yaml
kubectl apply -f flask-service.yaml

Deploy HPA 
kubectl apply -f flask-hpa.yaml


Access Flask from host:

If NodePort and nodePort is 30080:

curl http://127.0.0.1:30080/




Verify DB operations:
curl -X POST -H "Content-Type: application/json" -d '{"sampleKey":"sampleValue"}' http://<minikube-ip>:30080/data
curl http://<minikube-ip>:30080/data

