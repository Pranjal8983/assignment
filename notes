#Can you explain the benefits of using a virtual environment for python applications?
Using a virtual environment for Python applications offers several benefits:
Dependency Isolation:Virtual environments create isolated spaces for each project,
preventing conflicts between different projects that might require different versions of the same library.
Reproducibility and Portability:By creating a requirements.txt file within a virtual environment
, we can easily document and share the exact dependencies and their versions needed for a project.
Cleaner System-Wide Python Installation:Virtual environments prevent the cluttering of our global
Python installation with project-specific packages.
This keeps our system Python clean and stable, avoiding potential issues with system-level scripts
or other applications relying on the global installation.
Testing with Different Python Versions:we can create virtual environments with different Python versions, 
allowing us to test our application's compatibility across various Python releases without affecting our main Python installation.
Enhanced Security: Isolating dependencies within a virtual environment can mitigate risks associated with
unintentional library upgrades or security vulnerabilities that might affect a global installation.
==================================================================================
#DNS resolution within Kubernete

Kubernetes provides an internal DNS, which resolves service names to cluster IPs.

When we create a Service named mongo in namespace default, its DNS name is 
mongo.default.svc.cluster.local. Pods can simply use mongo and the environment & kube DNS will resolve to the ClusterIP.
========================================================================
#explanation of resource requests and limits in Kubernetes
When we specify a Pod, we can optionally specify how much of each resource a container needs. 
The most common resources to specify are CPU and memory (RAM); there are others.
When we specify the resource request for containers in a Pod, the kube-scheduler
uses this information to decide which node to place the Pod on. When we specify 
a resource limit for a container, the kubelet enforces those limits so that the 
running container is not allowed to use more of that resource than the limit we set. 
The kubelet also reserves at least the request amount of that system resource specifically 
for that container to use
